---
author: "Serhii Polishchuk"
title: "Модули (Module) LiveStreet"
date: 2012-09-23
tags: []
draft: true
---
<!--more-->
Модули предназначены для объединения часто используемого функционала, т.е. некие аналоги внутренних библиотек. Например, модуль может содержать методы для обработки запросов к базе данных, подсчета некой статистики, работы с системой кеширования. Модули бывают двух типов - **системные**(модули ядра) и **пользовательские**(обычные модули). Отличие в них только одно \- системные находятся в каталоге **/engine/classes/modules/**, а пользовательские в каталоге **/classes/modules/**. Название класса модуля строится по шаблону **Module\[Name\]**, где **Name** \- это название модуля, первая буква должна быть заглавной, остальные в нижнем регистре. Например, **ModuleUser**. Класс модуля должен наследоваться от класса **Module** (/engine/classes/Module.class.php). Каждый модуль расположен в отдельном каталоге, название которого совпадает с именем модуля, но в нижнем регистре, например, **/classes/modules/user/**. Сам файл модуля также содержит его название - **User.class.php**, первая буква в верхнем регистре, остальные в нижнем.  Пример простого модуля ( **/classes/modules/user/User.class.php**):

```php
<?php

class ModuleUser extends Module {
        /**
         * Инициализация
         *
         */
        public function Init() {
                // здесь какие либо действи при инициализации модуля
        }

        /**
         * Некий метод модуля
         *
         */
        public function SomeFunction() {

        }

        /**
         * Вызываетс автоматически при завершении работы модуля
         *
         */
        public function Shutdown() {

        }
}
```

Обязательным методом для модуля является **Init()** \- он автоматически выполняется **один раз** при инициализации модуля. Инициализация происходит при первом обращении к модулю, либо при инициализации ядра (engine) если модуль добавлен в автозагрузку через конфиг:

```php
$config["module"]["autoLoad"] = array("Hook","Cache","User");
```

Здесь в массиве перечисляются модули, которые должны загружаться вместе с ядром. Метод **Shutdown()** выполняется автоматически при завершении модуля. Процедура завершения всех активных(инициализированных) модулей запускается ядром при его завершении. Обращение к методам модуля в большинстве случаев(в экшенах, хуках, модулях, блоках, сущностях, плагинах) осуществляется через **$this->Module\_Method()**, например, **$this->User\_SomeFunction()**. Но также можно обратиться к модулю через ядро: **Engine::getInstance()->User\_SomeFunction()**.

## Мапперы (Mapper)

Часто бывает, что в модулях требуется реализовать работу с базой данных. Для этого предусмотрены специальные объекты - **Mapper**. Вся задача маппера сводится в выполнению запроса к базе данных и возвращения результата в модуль. Мапперы находятся в подкаталоге **/mapper/** в каталоге с модулем, например, **/classes/modules/user/mapper/**. Название класса состоит из двух частей **Module\[Name\]\_Mapper\[NameMapper\]**, где **Name** \- это название модуля, а **NameMapper** \- это название маппера(как обычно первая буква заглавная, остальные в нижнем регистре), например, **ModuleUser\_MapperTest**. Зачастую название маппера совпадает с названием модуля. Класс маппера должен наследоваться от класса **Mapper** (/engine/classes/Mapper.class.php). Файл маппера называется по шаблону **\[NameMapper\].mapper.class.php**, например, **Test.mapper.class.php**. Пример простого маппера ( **/classes/modules/user/mapper/Test.mapper.class.php**) :

```php
<?php

class ModuleUser_MapperTest extends Mapper {
        /**
         * Получает пользователя по его логину из таблицы user
         *
         * @param string $sLogin
         * @return unknown
         */
        public function GetUserByLogin($sLogin) {
                $sql = "SELECT
                                *
                        FROM
                                ".Config::Get('db.table.user')."
                        WHERE
                                user_login = ? ";
                if ($aRow=$this->oDb->selectRow($sql,$sLogin)) {
                        return Engine::GetEntity("User",$aRow);;
                }
                return null;
        }
}
```

В данном примере метод **GetUserByLogin()** выполняет запрос к базе данных для получения пользователя по логину из таблицы **user** и возвращает [объект сущности](http://web.archive.org/web/20100724120400/http://trac.lsdev.ru/livestreet/wiki/DeveloperDoc/Module#СущностиEntity) пользователя. Непосредственно сам запрос выполняется через свойство маппера **$oDb**, в котором содержится объект для работы с БД. Таблица для запроса получается из конфига, где определен список таблиц и их префикс в БД ( **/config/config.php**):

```php
<?php
/**
 * Настройка таблиц базы данных
 */
$config['db']['table']['prefix'] = 'prefix_';

$config['db']['table']['user'] = '___db.table.prefix___user';

$config['db']['tables']['engine'] = 'InnoDB';  // InnoDB или MyISAM
```

Настройки самого подключения к базе данных также находятся в конфиге:

```php
<?php
/**
 * Настройка базы данных
 */
$config['db']['params']['host']   = 'localhost';
$config['db']['params']['port']   = '3306';
$config['db']['params']['user']   = 'root';
$config['db']['params']['pass']   = '';
$config['db']['params']['type']   = 'mysql';
$config['db']['params']['dbname'] = 'social';
```

Пример модуля с использованием маппера:

```php
<?php

class ModuleUser extends Module {
        /**
         * Объект маппера
         *
         * @var Mapper
         */
        protected $oMapper=null;

        /**
         * Инициализация
         *
         */
        public function Init() {
                /**
                 * Получаем маппер по его имени
                 */
                $this->oMapper=Engine::GetMapper(__CLASS__,"Test");
        }

        /**
         * Получает пользователя по его логину
         *
         * @param string $sLogin
         * @return unknown
         */
        public function GetUserByLogin($sLogin) {
                return $this->oMapper->GetUserByLogin($sLogin);
        }
}
```

Объект маппера получается через статический метод ядра: **Engine::GetMapper(\[ClassModule\],\[NameMapper\]);**, где **ClassModule** \- это им класса модуля к которому относится маппер, а **NameMapper** \- это название маппера, например, **Engine::GetMapper('ModuleUser','Test')**.

## Сущности (Entity)

При запросе к базе данных удобно возвращать не просто массив данных, а данные в виде специального объекта - **Entity**. Основные методы такого объекта делятся на два вида: get-методы и set-методы. Первые получают свойство объекта по его имени, а вторые устанавливают. Сущности находятся в подкаталоге **/entity/** в каталоге с модулем, например, **/classes/modules/user/entity/**. Название класса состоит из двух частей **Module\[Name\]\_Entity\[NameEntity\]**, где **Name** \- это название модуля, а **NameEntity** \- это название сущности, например, **ModuleUser\_EntityUser**, **ModuleUser\_EntitySession** или **ModuleUser\_EntityUserVote**. Класс сущности должен наследоваться от класса **Entity**(/engine/classes/Entity.class.php). Файл сущности называется по шаблону **\[NameEntity\].entity.class.php**, например, **UserVote.entity.class.php**. Пример сущности (/classes/modules/user/entity/User.entity.class.php) :

```php
<?php

class ModuleUser_EntityUser extends Entity {

        public function getLogin() {
                return $this->_aData["user_login"];
        }

        public function setLogin($data) {
                $this->_aData["user_login"]=$data;
        }
}
```

Данные у сущности хранятся в ассоциативном массиве **$this->\_aData**. Описывать все поля сущности нет необходимости, если использовать camel-style при наименовании методов. Например следующие две сущности эквивалентны:

```php
<?php
/**
 * Первый вариант
 *
 */
class ModuleUser_EntityUser extends Entity {
        public function getLogin() {
                return $this->_aData["login"];
        }

        public function getProfileName() {
                return $this->_aData["profile_name"];
        }

        public function setLogin($data) {
                $this->_aData["login"]=$data;
        }
        public function setProfileName($data) {
                $this->_aData["profile_name"]=$data;
        }
}

/**
 * Второй вариант
 *
 */
class ModuleUser_EntityUser extends Entity {

}
```

Во втором варианте обращение к методам сущности автоматически преобразуется в ключ ассоциативного массива. Например, **OneTwoThreeFour** преобразуется в **one\_two\_three\_four**. Также доступны дополнительные методы:

```php
<?php
/**
 * Устанавливает значения сущности из ассоциативного массива $aData
 *
 */
function _setData($aData)

/**
 * Возвращает ассоциативный массив значений сущности.
 * Если передан параметр $aKeys, то вернуться только те значения, ключи которых перечислены в этом параметре.
 */
function _getData($aKeys=array())
```

Создание объектов сущностей происходит через статический метод ядра:

```
123,'key'=>'qwerty'));
/**
 * Возвращает объект сущности User модуля User.
 * Если название сущности совпадает с названием модуля, то допускается короткая запись:  User_User = User
 */
$oUser=Engine::GetEntity('User',$aData);
?>
```

## Системные модули

Системные модули (модули ядра) находятся в каталоге **/engine/classes/modules/**.

### Cache

Модуль кеширования. Для реализации кеширования используетс библиотека **Zend\_Cache** с двумя бэкэндами File и Memcache. Т.к. в memcache нет встроенной поддержки тегирования при кешировании, то для реализации тегов используется враппер для Zend\_Cache\_Backend\_Memcached от Дмитрия Котерова - **Dklab\_Cache\_Backend\_TagEmuWrapper**. Настройки кеширования устанавливаются в конфиге (/config/config.php) :

```

```

Доступные методы модуля кеширования:

```

```

Пример использования кеширования:

```
oMapper=Engine::GetMapper(__CLASS__,'Test');
        }
        /**
         * Получает пользователя по его логину
         *
         * @param string $sLogin
         * @return unknown
         */
        public function GetUserByLogin($sLogin) {
                /**
                 * Пытаемся получить значение из кеша
                 */
                if (false === ($oUser = $this->Cache_Get("user_login_{$sLogin}"))) {
                        /**
                         * Если значение из кеша получить не удалось, то обращаемся к базе данных
                         */
                        $oUser = $this->oMapper->GetUserByLogin($sLogin);
                        /**
                         * Записываем значение в кеш
                         */
                        $this->Cache_Set($oUser, "user_login_{$sLogin}", array(), 60*60*24*5);
                }
                return $oUser;
        }
        /**
         * Обновляет пользовател в БД
         */
        public function UpdateUser($oUser) {
                /**
                 * Удаляем кеш конкретного пользователя
                 */
                $this->Cache_Delete("user_login_{$oUser->getLogin()}");
                /**
                 * Удалем кеш со списком всех пользователей
                 */
                $this->Cache_Clean(Zend_Cache::CLEANING_MODE_MATCHING_TAG,array('user_update'));
                /**
                 * Обновлем пользовател в базе данных
                 */
                return $this->oMapper->UpdateUser($oUser);
        }
        /**
         * Получает список всех пользователей
         */
        public function GetUsers() {
                /**
                 * Пытаемся получить значение из кеша
                 */
                if (false === ($aUserList = $this->Cache_Get("users"))) {
                        /**
                         * Если значение из кеша получить не удалось, то обращаемся к базе данных
                         */
                        $aUserList = $this->oMapper->GetUsers();
                        /**
                         * Записываем значение в кеш
                         */
                        $this->Cache_Set($oUser, "users", array('user_update'), 60*60*24*5);
                }
                return $aUserList;
        }
}
?>
```

### Database

Модуль для работы с базой данных. Работа с базой данных осуществляется через внешнюю библиотеку от Дмитрия Котерова - **DbSimple**. Задача модуля Database сводится к получению экземпляра объекта DbSimple, используя параметры подключения к базе данных.

```

```

Дефолтные настройки коннекта к БД хранятся в конфиге:

```

```

Также в конфиге можно указать настройки логирования SQL запросов:

```

```

В мапперах объект DbSimple содержится в свойстве **$this->oDb**. Пример запроса к БД из маппера:

```
oDb->selectRow($sql,$sLogin)) {
                        return Engine::GetEntity('User',$aRow);;
                }
                return null;
        }
}
?>
```

Более подробно ознакомиться с DbSimple и синтаксисом плейсхолдеров в SQL запросах можно на [странице документации к DbSimple](http://web.archive.org/web/20100724120400/http://dklab.ru/lib/DbSimple/manual.html).

### Image

Модуль для обработки изображений, использует библиотеку LiveImage (/engine/lib/external/LiveImage/). Настройки обработки изображений хранятся в конфиге. Можно создавать любое количество групп настроек, по умолчанию используется группа **default** :

```

```

Основные методы модуля:

```
:  array('title'=>'my title','alt'=>'my alt','align'=>'left')
 */
function BuildHTML($sPath,$aParams)
```

### Lang

Модуль для работы с языковыми текстами, позволяет реализовать мультиязычный интерфейс на сайте. Языковые тексты хранятся в языковых файлах, название файла соответствует языку текста содержащегося в нем, например, **russian.php**.

```
 'Блоги',
        'blogs_rating' => 'Рейтинг',
        'blogs_owner' => 'Смотритель: %%login%% ',
);
?>
```

Структура расположения языковых файлов следующая:

```

```

Настройки модуля:

```

```

При использовании кеширования с memcache, текстовки кешируются в памяти на 1 час. Основные методы модуля:

```
'Ivan') заменит %%login%% на 'Ivan'
 */
function Get($sName,$aReplace=array())

/**
 * Добавляет к текстовках новые тексты из массива
 * $aMessages - массив текстовок, например, array('new_text'=>'new text')
 */
function AddMessages($aMessages)

/**
 * Добавлет новую текстовку
 * $sKey - имя текстовки
 * $sMessage - значение текстовки, т.е. сам текст
 */
function AddMessage($sKey, $sMessage)
?>
```

### Logger

Модуль логирования. Позволяет вести логи каких-либо действий. Все логи хранятся в каталоге **/logs/**. В конфиге определяется имя файла лога по умолчанию:

```

```

Логгер поддерживает 3 уровня логирования по возрастающему приоритету: **'DEBUG**', **'NOTICE**' и **'ERROR**'. Логирование происходит только тогда, кода установленный уровень логирования **больше либо равен** уровню текущей записи в лог. Основные методы модуля:

```

```

### Mail

Модуль для отправки почты на e-mail адреса. Для реализации отправки почты модуль использует библиотеку **phpMailer** (/engine/lib/external/phpMailer/). Настройки модуля в конфиге:

```

```

Основные методы модуля:

```

```

Пример отправки почты:

```
Mail_SetAdress('user@domain.com','Ivan');
$this->Mail_SetSubject('Test mail');
$this->Mail_SetBody('Hello, Ivan!');
$this->Mail_setHTML();
$this->Mail_Send();
?>
```

### Message

Модуль обработки системных сообщений. Необходим для отображения пользователю каких\-либо информационных сообщений. Поддерживается две очереди сообщений \- сообщения об ошибке и информационные сообщения. Сообщения могут отображаться как в текущем сеансе, так и при следующем обращении к сайту (использование сессионных сообщений). При завершении работы модуля он передает массивы (очереди) сообщений в шаблон: **$aMsgError** и **$aMsgNotice**. Основные методы модуля:

```

```

### Security

Модуль безопасности. На данный момент проверяет только корректность отправленных данных серверу. Для этого перед обработкой данных необходимо вызвать метод:

```

```

Этот метод вернет true только в том случае, если при отправке данных был передан правильный ключ (GET/POST параметр **security\_ls\_key** ). Данный параметр (ключ) автоматически прогружается в шаблон с именем **$LIVESTREET\_SECURITY\_KEY**. Данный параметр уникальный для каждой PHP сессии, т.е. фактически уникальный для каждого пользователя. В конфиге определяется "соль" для генерации ключа:

```

```

Использование данного модуля предотвращает возможность "фоновой" отправки форм/данных при посещении пользователем злонамеренных сайтов.

### Session

Модуль для работы с PHP сессиями. Поддерживает два механизма работы: через стандартных механизм PHP сессий и через собственный. Второй вариант до конца не протестирован, поэтому строго рекомендуется использовать первый, т.е. через стандартные сессии. Настройки модуля в конфиге:

```

```

Основные методы модуля:

```

```

### Text

Модуль обработки и типографирования текста. Модуль использует библиотеку типографа Jevix (/engine/lib/external/Jevix/). Основная задача модуля - это удаление из текста недопустимых HTML тегов и фильтрация на вставку JavaScript. Основные методы модуля:

```
. Поддерживает обработку youtube.com и rutube.ru
 * $sText - исходный текст
 */
function VideoParser($sText)

/**
 * Заменяет в тексте тег  на
```

```
для подстветки через JavaScript * $sText - исходный текст */ function CodeSourceParser($sText) /** * Производить резрезание текста по тегу . * $sText - исходный текст * Возвращаем массив вида: * array( * $sTextShort - текст до тега  * $sTextNew - весь текст за исключением удаленного тега * $sTextCut - именованное значение  * ) */ function Cut($sText) ?>
```
